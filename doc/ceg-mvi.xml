<?xml version="1.0" ?>
<!-- $Id$ -->
<notes>
Documenting a big project often requires multiple diagrams:
each to show a specific and limited portion of the system.
Each diagram is usually composed of few classes, possibily using a different detail level.<p/>
The <code>@view</code> tag, marks a special class used to describe a single class diagram.
Similarly to UMLOptions, the view can define its own general options,
but what makes it interesting is the ability to specify package based 
<em>overrides</em> that allow to adopt different options based on the package the classes are in.
The general syntax for defining a view is:
<fmtcode ext="java">
/**
 * @view
 * @opt [!]viewOption1
 * @opt [!]viewOption2
 * @match regularExpression1
 * @opt [!]option1.1 [argument]
 * @opt [!]option1.2 [argument]
 * ...
 * @match regularExpression2
 * @opt [!]option2.1 [argument]
 * @opt [!]option2.2 [argument]
 * ... 
 */
</fmtcode>

The view options are applied to every class in the view (so they are the
global options for this class diagram).<br/>
The regular expression will be used to match a single class, a group of 
classes, or a package, and the options that follow will be applied to
those classes. <br/>
Multiple matches will be evaluted in the order of specification.<br/>
Refer to the <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/regex/Pattern.html">Pattern</a> 
class documentation for details on a proper regular expression specification.

<p/>Each view will generate a .dot file whose name is the name of the view,
unless the "output" option is specified to override it.

<h2>Example: views at different detail of specification</h2>

The previous multiple view example can be generated by using internal
view support by means of the following sources (note the use of UmlOptions
to set the common appearance options, and the views to generate multiple
diagrams at different detail level).

<fmtcode ext="java">
// Author:  Vadim Nasardinov
// Author:  Andrea Aime
// Version: $Id$

import java.util.List;
import java.util.Map;

/**
 * @assoc "1..1" - "0..n" Adapter
 * @assoc "" - "0..n" ObjectType
 * @assoc "" - "0..n" ObjectMap
 * @assoc "" - "0..n" Table
 * @assoc "" - "0..n" DataOperation
 **/
class Root {
    private Map m_adapters;
    private List m_types;
    private List m_maps;
    private List m_tables;
    private List m_ops;

    public Adapter getAdapter(Class klass) {}
}

class Adapter {
    public Root getRoot();
}

abstract class Element {
    Root getRoot() {}
}

class ObjectType extends Element {}

/**
 * @has "1..1" - "1..1" ObjectType
 **/
class ObjectMap extends Element {
    private ObjectType m_type;
}

class Table extends Element {}

class DataOperation extends Element {}

/**
 * @hidden
 * @opt nodefontname luxisr 
 * @opt nodefontabstractname luxisri
 * @opt edgefontname luxisr
 * @opt nodefontsize 8 
 * @opt edgefontsize 8
 * @opt nodefillcolor LemonChiffon
 */
class UMLOptions {}

/**
 * @view
 * @opt attributes
 * @opt operations
 */
class DetailedView {}

/**
 * @view
 */
class Overview {}
</fmtcode>

and by invoking the following commands (assuming UmlGraph.jar is in the
current directory):

<fmtcode ext="bat">
javadoc -doclet gr.spinellis.umlgraph.doclet.UmlGraph -private -docletpath UmlGraph.jar -views RootViews.java
dot -Tpng -o root-small.png Overview.dot
dot -Tpng -o root.png DetailedView.dot
</fmtcode>

<h2>Example: per package views</h2>

Views are especially interesting in big projects, since they allow to
generate package specific diagrams and overview diagrams in a quick and
consistent way. Add ant/make automation and the project class diagram will
always be up to date.

<em>Postponed until I have finished the association/dependency inference
   so that I don't have to modify source files to generate class diagrams
</em>

</notes>
